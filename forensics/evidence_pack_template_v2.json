{
  "_description": "Multi-mode template for the forensics_analysis pipeline output (evidence pack). Modes: Graphic (no OCR/semantic), Reading (only OCR+semantic), FULL (everything).",
  "_version": "1.0.0",
  "modes": {
    "Graphic": {
      "_description": "GRAPHIC mode — contains all non-OCR/non-semantic fields (unchanged).",
      "_version": "1.0.0",

      "image_id": "<string: filename of the input image, e.g. 'receipt_001.png'>",
      "input_path": "<string: absolute path to the source image>",
      "output_dir": "<string: absolute path to the output directory>",

      "global": {
        "_description": "Merged global metrics from metadata, quality, entropy/edge, and skew modules.",

        "path": "<string: same as input_path>",
        "filename": "<string: image filename>",
        "bytes": "<int|null: file size in bytes>",
        "error": "<string|null: metadata extraction error, if any>",
        "format": "<string|null: image codec, e.g. 'PNG', 'JPEG'>",
        "mode": "<string|null: PIL colour mode, e.g. 'RGB', 'RGBA'>",
        "width": "<int: image width in pixels>",
        "height": "<int: image height in pixels>",
        "horizontal_resolution": "<float|null: horizontal DPI>",
        "vertical_resolution": "<float|null: vertical DPI>",
        "has_alpha": "<bool: true if the image has an alpha channel>",
        "bit_depth": "<int|null: estimated bit depth from colour mode>",
        "exif_orientation": "<int|null: EXIF orientation tag (274)>",
        "aspect_ratio": "<float|null: width / height>",

        "brightness_mean": "<float: mean grayscale intensity (0-255)>",
        "brightness_std": "<float: std of grayscale intensity>",
        "contrast_std": "<float: contrast proxy (same as brightness_std)>",
        "blur_laplacian_var": "<float|null: variance of Laplacian — higher means sharper>",

        "blur_tiles": {
          "_description": "Per-tile Laplacian blur variance statistics.",
          "blur_tile_mean": "<float|null: mean Laplacian variance across tiles>",
          "blur_tile_std": "<float|null: std deviation across tiles>",
          "blur_tile_min": "<float|null: minimum tile blur>",
          "blur_tile_max": "<float|null: maximum tile blur>",
          "tile": "<int: tile side length in pixels>",
          "tiles_hw": ["<int: number of tile rows>", "<int: number of tile columns>"]
        },

        "entropy": "<float: Shannon entropy of grayscale histogram (0-8 bits)>",
        "edge_density": "<float|null: fraction of Canny edge pixels>",
        "edge_method": "<string: 'canny' or 'none'>",
        "edge_threshold": ["<int: low threshold>", "<int: high threshold>"],
        "text_ink_ratio": "<float|null: fraction of ink pixels via adaptive threshold>",
        "method": "<string: 'adaptive+open' or 'none'>",
        "params": {
          "block": "<int: adaptive threshold block size>",
          "C": "<int: adaptive threshold constant>"
        },

        "skew_angle_deg": "<float|null: estimated skew angle in degrees (positive=clockwise)>",
        "skew_confidence": "<float|null: confidence score 0-1 (inverse MAD)>",
        "method": "<string: 'hough' or 'none'>"
      },

      "forensic": {
        "_description": "Summary results from each forensic analysis module.",

        "mela": {
          "_description": "Multi-Quality Error Level Analysis summary.",
          "used_qualities": ["<int: JPEG quality levels tested, e.g. 95, 90, 85>"],
          "block_sizes": ["<int: local-variance kernel sizes, e.g. 8, 16, 32>"],
          "thr_percentile": "<float: percentile used for thresholding (e.g. 99.3)>",
          "threshold_value": "<float: computed threshold value>",
          "suspicious_ratio": "<float: fraction of pixels above threshold (0-1)>",
          "peak_score": "<float: maximum value in the fused variance map>",
          "percentiles": {
            "p50": "<float>",
            "p75": "<float>",
            "p90": "<float>",
            "p95": "<float>",
            "p97": "<float>",
            "p99": "<float>"
          }
        },

        "noise": {
          "_description": "Residual-noise tile inconsistency summary.",
          "tile": "<int: tile side length in pixels>",
          "sigma": "<float: Gaussian blur sigma>",
          "max_tile_z": "<float: maximum Z-score across tiles>",
          "mean_abs_resid": "<float: global mean absolute residual>",
          "std_tile_mean_abs_resid": "<float: std of per-tile mean abs residual>"
        },

        "copy_move": {
          "_description": "ORB-based copy-move detection summary.",
          "pairs_found": "<int: number of detected source/destination pairs>",
          "good_matches": "<int: total ORB matches passing the ratio test>",
          "keypoints": "<int: total ORB keypoints detected>",
          "reason": "<string|absent: explanation when pairs_found is 0>"
        }
      },

      "suspect_rois": [
        {
          "_description": "Region of interest flagged by MELA (ROI dataclass serialised to dict).",
          "roi_id": "<string: unique ID, e.g. 'r1'>",
          "bbox": ["<int: x>", "<int: y>", "<int: width>", "<int: height>"],
          "score": "<float: mean anomaly score in 0-1>",
          "signals": ["<string: signal name, e.g. 'mela_hotspot'>"],
          "entity_hint": "<string|null: semantic hint>",
          "ocr_snippet": "<string|null: OCR text from this region>",
          "crop_path": "<string|null: path to the saved ROI crop image>"
        }
      ],

      "copy_move_pairs": [
        {
          "_description": "A detected copy-move source/destination pair.",
          "translation_bin": ["<int: binned dx>", "<int: binned dy>"],
          "matches_in_cluster": "<int: number of keypoint matches in this cluster>",
          "src_bbox": ["<int: x>", "<int: y>", "<int: w>", "<int: h>"],
          "dst_bbox": ["<int: x>", "<int: y>", "<int: w>", "<int: h>"]
        }
      ],

      "artifacts": {
        "_description": "Paths to all saved image artifacts.",
        "input_image": "<string: path to the original input image>",
        "mela": {
          "mela_heat": "<string: path to grayscale MELA heatmap PNG>",
          "mela_overlay": "<string: path to red-overlay PNG>",
          "mela_rois": "<string: path to image with green ROI bboxes>",
          "mela_roi_crops": ["<string: path to individual ROI crop PNGs>"]
        },
        "noise": {
          "noise_heat": "<string: path to noise heatmap PNG>",
          "noise_overlay": "<string: path to noise overlay PNG>"
        },
        "copymove": {
          "copymove_rois": "<string: path to image with copy-move bboxes>",
          "copymove_pair_grids": ["<string: path to side-by-side pair crop PNGs>"]
        }
      },

      "errors": {
        "_description": "Module-level errors. Empty dict when all modules succeed.",
        "<module_name>": "<string: error type and message>"
      },

      "timing_ms": {
        "total": "<int: total pipeline execution time in milliseconds>"
      },

      "evidence_json": "<string: path to this evidence pack JSON file>"
    },

    "Reading": {
      "_description": "READING mode — contains only OCR post-processing + semantic checks outputs.",
      "_version": "1.0.0",

      "image_id": "<string: filename of the input image, e.g. 'receipt_001.png'>",
      "input_path": "<string: absolute path to the source image>",

      "ocr": {
        "_description": "Output from ocr_postprocess.py (OCRExtractionResult). NOTE: This is NOT an OCR engine; it post-processes an existing OCR transcription (paired .txt) and computes arithmetic validation.",
        "source": {
          "engine": "<string: 'txt'|'paddleocr'|'none' — where the transcription came from; ocr_postprocess consumes the produced text>",
          "txt_path": "<string|null: path to paired OCR .txt if used>",
          "has_boxes": "<bool: true if bbox data is available (usually false for txt)>"
        },
        "structured": {
          "_description": "Structured OCR text and candidates (OCRStructured).",
          "quality_score": "<float: heuristic quality score in [0,1]>",
          "cleaned_text": "<string: cleaned OCR text capped for prompt size>",
          "company_lines": ["<string: best header/company lines>"],
          "date_candidates": ["<string: raw lines that look like dates>"],
          "total_candidates": ["<string: lines likely containing totals/subtotals/taxes/etc>"],
          "item_candidates": ["<string: lines likely containing item prices>"],
          "payment_candidates": ["<string: lines likely containing paid/change/tendered>"],
          "all_amounts": ["<string: unique amounts parsed as decimals, sorted>"],

          "parsed_lines_sample": [
            {
              "_description": "Sample of parsed lines (OCRLine).",
              "idx": "<int: 0-based line index>",
              "text": "<string: original line>",
              "norm": "<string: normalized (uppercased, collapsed whitespace)>",
              "keywords": ["<string: inferred semantic tags e.g. 'TOTAL','TAX','PAID','CHANGE'>"],
              "money": [
                {
                  "_description": "MoneyToken extracted from the line (already parsed).",
                  "raw": "<string: raw token text, e.g. 'RM12.90' or '12,90'>",
                  "value": "<string: decimal with sign, e.g. '12.90'>",
                  "currency": "<string|null: detected currency token if present>"
                }
              ]
            }
          ],

          "parsed_lines_full": "<array|absent: optional full parsed_lines list (can be large; include only when needed)>"
        },

        "arithmetic_report": {
          "_description": "Arithmetic verification report computed from structured OCR (ArithmeticReport).",
          "item_count": "<int: number of item lines parsed>",
          "item_sum": "<string: sum(items) as decimal string>",
          "subtotal": "<string|null: extracted subtotal>",
          "tax": "<string|null: extracted tax>",
          "discount": "<string|null: extracted discount (sign normalized by the checker)>",
          "rounding": "<string|null: extracted rounding adjustment>",
          "service_charge": "<string|null: extracted service charge>",
          "total": "<string|null: extracted total>",
          "paid": "<string|null: extracted paid/tendered>",
          "change": "<string|null: extracted change/cashback>",

          "checks": [
            {
              "_description": "ArithmeticCheck emitted by ocr_postprocess.py.",
              "name": "<string: check id, e.g. 'items_vs_subtotal'|'expected_total_vs_total'|'paid_minus_change_vs_total'>",
              "lhs": "<string|null: left-hand side value>",
              "rhs": "<string|null: right-hand side value>",
              "diff": "<string|null: rhs-lhs or documented diff meaning>",
              "diff_pct": "<float|null: percentage difference when applicable>",
              "passes": "<bool|null: true/false/None>",
              "details": "<object: structured details, fields vary by check>"
            }
          ],

          "arithmetic_consistent": "<bool|null: overall consistency decision>",
          "best_explanation": "<string|null: name of the most informative check>"
        }
      },

      "semantic_checks": {
        "_description": "Output from semantic_checks_v2.py — semantic accounting checks built on ocr_postprocess structured output + arithmetic report. Includes strict subtotal+tax≈total and may include arith::* checks (mirrors arithmetic_report checks in a uniform format).",
        "engine": "<string: e.g. 'semantic_checks_v2'>",
        "strict_config": {
          "strict_tol_abs": "<string: e.g. '0.02'>",
          "strict_tol_pct": "<string|null: optional percentage tolerance>",
          "evidence_max_len": "<int: max chars per evidence line>"
        },
        "checks": [
          {
            "_description": "Semantic check entry (uniform shape).",
            "name": "<string: check id, e.g. 'subtotal+tax≈total_strict' or 'arith::expected_total_vs_total' or 'arith::overall'>",
            "passed": "<bool|null: true/false/None>",
            "details": "<string: human-readable explanation>",
            "evidence": {
              "subtotal_line": "<string|null: raw OCR line matched as subtotal>",
              "tax_line": "<string|null: raw OCR line matched as tax>",
              "total_line": "<string|null: raw OCR line matched as total>"
            },
            "values": "<object|absent: optional structured numeric payload (lhs/rhs/diff/etc)>"
          }
        ]
      }
    },

    "FULL": {
      "_description": "FULL mode — contains the complete evidence pack: Graphic + Reading combined.",
      "_version": "1.0.0",

      "image_id": "<string: filename of the input image, e.g. 'receipt_001.png'>",
      "input_path": "<string: absolute path to the source image>",
      "output_dir": "<string: absolute path to the output directory>",

      "global": {
        "_description": "Merged global metrics from metadata, quality, entropy/edge, and skew modules.",

        "path": "<string: same as input_path>",
        "filename": "<string: image filename>",
        "bytes": "<int|null: file size in bytes>",
        "error": "<string|null: metadata extraction error, if any>",
        "format": "<string|null: image codec, e.g. 'PNG', 'JPEG'>",
        "mode": "<string|null: PIL colour mode, e.g. 'RGB', 'RGBA'>",
        "width": "<int: image width in pixels>",
        "height": "<int: image height in pixels>",
        "horizontal_resolution": "<float|null: horizontal DPI>",
        "vertical_resolution": "<float|null: vertical DPI>",
        "has_alpha": "<bool: true if the image has an alpha channel>",
        "bit_depth": "<int|null: estimated bit depth from colour mode>",
        "exif_orientation": "<int|null: EXIF orientation tag (274)>",
        "aspect_ratio": "<float|null: width / height>",

        "brightness_mean": "<float: mean grayscale intensity (0-255)>",
        "brightness_std": "<float: std of grayscale intensity>",
        "contrast_std": "<float: contrast proxy (same as brightness_std)>",
        "blur_laplacian_var": "<float|null: variance of Laplacian — higher means sharper>",

        "blur_tiles": {
          "_description": "Per-tile Laplacian blur variance statistics.",
          "blur_tile_mean": "<float|null: mean Laplacian variance across tiles>",
          "blur_tile_std": "<float|null: std deviation across tiles>",
          "blur_tile_min": "<float|null: minimum tile blur>",
          "blur_tile_max": "<float|null: maximum tile blur>",
          "tile": "<int: tile side length in pixels>",
          "tiles_hw": ["<int: number of tile rows>", "<int: number of tile columns>"]
        },

        "entropy": "<float: Shannon entropy of grayscale histogram (0-8 bits)>",
        "edge_density": "<float|null: fraction of Canny edge pixels>",
        "edge_method": "<string: 'canny' or 'none'>",
        "edge_threshold": ["<int: low threshold>", "<int: high threshold>"],
        "text_ink_ratio": "<float|null: fraction of ink pixels via adaptive threshold>",
        "method": "<string: 'adaptive+open' or 'none'>",
        "params": {
          "block": "<int: adaptive threshold block size>",
          "C": "<int: adaptive threshold constant>"
        },

        "skew_angle_deg": "<float|null: estimated skew angle in degrees (positive=clockwise)>",
        "skew_confidence": "<float|null: confidence score 0-1 (inverse MAD)>",
        "method": "<string: 'hough' or 'none'>"
      },

      "forensic": {
        "_description": "Summary results from each forensic analysis module.",

        "mela": {
          "_description": "Multi-Quality Error Level Analysis summary.",
          "used_qualities": ["<int: JPEG quality levels tested, e.g. 95, 90, 85>"],
          "block_sizes": ["<int: local-variance kernel sizes, e.g. 8, 16, 32>"],
          "thr_percentile": "<float: percentile used for thresholding (e.g. 99.3)>",
          "threshold_value": "<float: computed threshold value>",
          "suspicious_ratio": "<float: fraction of pixels above threshold (0-1)>",
          "peak_score": "<float: maximum value in the fused variance map>",
          "percentiles": {
            "p50": "<float>",
            "p75": "<float>",
            "p90": "<float>",
            "p95": "<float>",
            "p97": "<float>",
            "p99": "<float>"
          }
        },

        "noise": {
          "_description": "Residual-noise tile inconsistency summary.",
          "tile": "<int: tile side length in pixels>",
          "sigma": "<float: Gaussian blur sigma>",
          "max_tile_z": "<float: maximum Z-score across tiles>",
          "mean_abs_resid": "<float: global mean absolute residual>",
          "std_tile_mean_abs_resid": "<float: std of per-tile mean abs residual>"
        },

        "copy_move": {
          "_description": "ORB-based copy-move detection summary.",
          "pairs_found": "<int: number of detected source/destination pairs>",
          "good_matches": "<int: total ORB matches passing the ratio test>",
          "keypoints": "<int: total ORB keypoints detected>",
          "reason": "<string|absent: explanation when pairs_found is 0>"
        }
      },

      "suspect_rois": [
        {
          "_description": "Region of interest flagged by MELA (ROI dataclass serialised to dict).",
          "roi_id": "<string: unique ID, e.g. 'r1'>",
          "bbox": ["<int: x>", "<int: y>", "<int: width>", "<int: height>"],
          "score": "<float: mean anomaly score in 0-1>",
          "signals": ["<string: signal name, e.g. 'mela_hotspot'>"],
          "entity_hint": "<string|null: semantic hint>",
          "ocr_snippet": "<string|null: OCR text from this region>",
          "crop_path": "<string|null: path to the saved ROI crop image>"
        }
      ],

      "copy_move_pairs": [
        {
          "_description": "A detected copy-move source/destination pair.",
          "translation_bin": ["<int: binned dx>", "<int: binned dy>"],
          "matches_in_cluster": "<int: number of keypoint matches in this cluster>",
          "src_bbox": ["<int: x>", "<int: y>", "<int: w>", "<int: h>"],
          "dst_bbox": ["<int: x>", "<int: y>", "<int: w>", "<int: h>"]
        }
      ],

      "ocr": {
        "_description": "Output from ocr_postprocess.py (OCRExtractionResult). NOTE: This is NOT an OCR engine; it post-processes an existing OCR transcription (paired .txt) and computes arithmetic validation.",
        "source": {
          "engine": "<string: 'txt'|'paddleocr'|'none' — where the transcription came from; ocr_postprocess consumes the produced text>",
          "txt_path": "<string|null: path to paired OCR .txt if used>",
          "has_boxes": "<bool: true if bbox data is available (usually false for txt)>"
        },
        "structured": {
          "_description": "Structured OCR text and candidates (OCRStructured).",
          "quality_score": "<float: heuristic quality score in [0,1]>",
          "cleaned_text": "<string: cleaned OCR text capped for prompt size>",
          "company_lines": ["<string: best header/company lines>"],
          "date_candidates": ["<string: raw lines that look like dates>"],
          "total_candidates": ["<string: lines likely containing totals/subtotals/taxes/etc>"],
          "item_candidates": ["<string: lines likely containing item prices>"],
          "payment_candidates": ["<string: lines likely containing paid/change/tendered>"],
          "all_amounts": ["<string: unique amounts parsed as decimals, sorted>"],

          "parsed_lines_sample": [
            {
              "_description": "Sample of parsed lines (OCRLine).",
              "idx": "<int: 0-based line index>",
              "text": "<string: original line>",
              "norm": "<string: normalized (uppercased, collapsed whitespace)>",
              "keywords": ["<string: inferred semantic tags e.g. 'TOTAL','TAX','PAID','CHANGE'>"],
              "money": [
                {
                  "_description": "MoneyToken extracted from the line (already parsed).",
                  "raw": "<string: raw token text, e.g. 'RM12.90' or '12,90'>",
                  "value": "<string: decimal with sign, e.g. '12.90'>",
                  "currency": "<string|null: detected currency token if present>"
                }
              ]
            }
          ],

          "parsed_lines_full": "<array|absent: optional full parsed_lines list (can be large; include only when needed)>"
        },

        "arithmetic_report": {
          "_description": "Arithmetic verification report computed from structured OCR (ArithmeticReport).",
          "item_count": "<int: number of item lines parsed>",
          "item_sum": "<string: sum(items) as decimal string>",
          "subtotal": "<string|null: extracted subtotal>",
          "tax": "<string|null: extracted tax>",
          "discount": "<string|null: extracted discount (sign normalized by the checker)>",
          "rounding": "<string|null: extracted rounding adjustment>",
          "service_charge": "<string|null: extracted service charge>",
          "total": "<string|null: extracted total>",
          "paid": "<string|null: extracted paid/tendered>",
          "change": "<string|null: extracted change/cashback>",

          "checks": [
            {
              "_description": "ArithmeticCheck emitted by ocr_postprocess.py.",
              "name": "<string: check id, e.g. 'items_vs_subtotal'|'expected_total_vs_total'|'paid_minus_change_vs_total'>",
              "lhs": "<string|null: left-hand side value>",
              "rhs": "<string|null: right-hand side value>",
              "diff": "<string|null: rhs-lhs or documented diff meaning>",
              "diff_pct": "<float|null: percentage difference when applicable>",
              "passes": "<bool|null: true/false/None>",
              "details": "<object: structured details, fields vary by check>"
            }
          ],

          "arithmetic_consistent": "<bool|null: overall consistency decision>",
          "best_explanation": "<string|null: name of the most informative check>"
        }
      },

      "semantic_checks": {
        "_description": "Output from semantic_checks_v2.py — semantic accounting checks built on ocr_postprocess structured output + arithmetic report. Includes strict subtotal+tax≈total and may include arith::* checks (mirrors arithmetic_report checks in a uniform format).",
        "engine": "<string: e.g. 'semantic_checks_v2'>",
        "strict_config": {
          "strict_tol_abs": "<string: e.g. '0.02'>",
          "strict_tol_pct": "<string|null: optional percentage tolerance>",
          "evidence_max_len": "<int: max chars per evidence line>"
        },
        "checks": [
          {
            "_description": "Semantic check entry (uniform shape).",
            "name": "<string: check id, e.g. 'subtotal+tax≈total_strict' or 'arith::expected_total_vs_total' or 'arith::overall'>",
            "passed": "<bool|null: true/false/None>",
            "details": "<string: human-readable explanation>",
            "evidence": {
              "subtotal_line": "<string|null: raw OCR line matched as subtotal>",
              "tax_line": "<string|null: raw OCR line matched as tax>",
              "total_line": "<string|null: raw OCR line matched as total>"
            },
            "values": "<object|absent: optional structured numeric payload (lhs/rhs/diff/etc)>"
          }
        ]
      },

      "artifacts": {
        "_description": "Paths to all saved image artifacts.",
        "input_image": "<string: path to the original input image>",
        "mela": {
          "mela_heat": "<string: path to grayscale MELA heatmap PNG>",
          "mela_overlay": "<string: path to red-overlay PNG>",
          "mela_rois": "<string: path to image with green ROI bboxes>",
          "mela_roi_crops": ["<string: path to individual ROI crop PNGs>"]
        },
        "noise": {
          "noise_heat": "<string: path to noise heatmap PNG>",
          "noise_overlay": "<string: path to noise overlay PNG>"
        },
        "copymove": {
          "copymove_rois": "<string: path to image with copy-move bboxes>",
          "copymove_pair_grids": ["<string: path to side-by-side pair crop PNGs>"]
        }
      },

      "errors": {
        "_description": "Module-level errors. Empty dict when all modules succeed.",
        "<module_name>": "<string: error type and message>"
      },

      "timing_ms": {
        "total": "<int: total pipeline execution time in milliseconds>"
      },

      "evidence_json": "<string: path to this evidence pack JSON file>"
    }
  }
}